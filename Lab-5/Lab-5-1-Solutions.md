# Lab5-1 Sorular

Bu lab uygulamasında `Practical Malware Analysis` kitabıyla birlikte verilmiş olan `Lab03-04.exe` dosyası üzerinden analiz gerçekleştirilecek ve sorulan sorularak cevaplar verilmeye çalışılacaktır. 

Bu içeriklerin amacı, direkt olarak sorulan sorulara cevap vermek değil, aynı zamanda malware analizi konusunda aydınlatıcı ve faydalı bir içerik havuzu oluşturmaktadır. Gerektiği yerlerde detaya girilecektir. Zaten kitabı aldıysanız, kitabın bir bölümü bu soruların cevaplarını detaylı bir şekilde veriyor. Burada amaç, cevapların içerisinde gizli kalmış, değinilmesi gereken konulara da değinerek bir fayda sağlabilmek. O halde başlayalım.

İlk sorumuz,

**1- What is the address of DllMain?**

Bu labın içeriği IDA Pro'nun kullanımına yönelik ve toplamda 21 adet soru bulunmaktadır. Her sorunun cevabını maalesef ekran alıntıları yaparak uzun uzayıda anlatamayacağım. Önemli bulduğum kısımlarda detaya inip, gerekli görselleri paylaşacağım. Bazı sorularda ise sadece cevabı verip geçeceğim. O halde başlayalım.

İlk sorumuz bizden DllMain'in adresini soruyor. Chapter5 klasörü içerisindeki Lab05-01.dll dosyasını IDA Pro ile açtığımız vakit, bunun bir subroutine olduğunu ve başlangıcının da **1000D02E** adresi olduğunu görebiliriz.

**2- Use the Imports window to browse to gethostbyname. Where is the import located?**

gethostbyname importu `idate` bölümü içerisinde `100163CC` adresinde tanımlıdır. 

**3- How many functions call geyhostbyname?**

Bu fonksiyonun üzerine tıklayıp `x` tuşuna basarsanız, toplam kaç defa hangi fonskiyonlar tarafından çağırılmış görebilirsiniz. Aşağıdaki görselden de anlaşılacağı üzere gethostbyname **5 farklı fonksiyondan toplamda 9 defa** çağırılmıştır.

![](/Lab-5/images/Lab5-5-image.png "lab5")

**4- Focusing on the call to gethostbyname located at 0x100001757, can you figure out which DNS request will be made?**

Bize gethostbyname fonksiyonu çağırılırmadan önce hangi DNS sorgusunun yapılacağını sormaktadır. İnternette gethostbyname fonksiyonun araştırdığımda, aşağıdaki açıklamayı buldum.

> Given the name of a host, gethostbyname returns a pointer to the hostent structure containing the host's IP address and other information.

Yani özetle host adersinden resolution yapan bir fonksiyon. Mesela bu fonksiyona **localhost** değerini veriyorsunuz, size 127.0.0.1 değerini barındıran bir struct adresini dönüyor. Şimdi IDA Pro yardımıyla bu fonksiyon çağırılmadan önce tanımlanan `host` değerinin ne olduğunu bulacağız.

Sorumuzun cevabı = **pics.praticalmalwareanalysis.com** şeklindedir. Nasıl olduğunu ise aşağıdaki görsel üzerinden anlatalım.

![](/Lab-5/images/Lab5-5-image2.png "lab5")

Görselde de görüldüğü üzere, 0x10001757 numaralı adrese gittiğimizde, kırmızı kare içerisine alınmış instruction'lar dikkatimi çekti. Burada **0x10019040** adresinde tanımlı olan bir değer, EAX registerına atılmakta, daha sonra EAX register'ı 0Dh ile toplanıp, push komutu ile stack'e yüklenmektedir. Daha sonra malum fonksiyonumuz çağrılmıştır. Buradan da anlaşılacağı üzere, **0x10019040** adresindeki değer bizim sorgusunu yapacağımız host değeridir.

**5- How many local variables has IDA Pro recognized for the subroutine at 0x10001656?**

Aşağıdaki görselde görüldüğü gig0bi toplamda 20 adet local variable IDA Pro tarafından tanınmıştır.

![](/Lab-5/images/Lab5-5-image3.png "lab5")

**6- How many parameters has IDA Pro recognized for the subroutine at 0x10001656?**

1 adet parametre tanınmıştır.

**7- Use the Strings window to locate the string \cmd.exe /c in the disassembly. Where is it located?**

\cmd.exe \c ifeadesi xdoors_d isimli section'ın 10095B34 adresinde bulunmaktadır.

**8- What is happening in the area of code that references \cmd /c?**

cmd.exe'nin referanse edildiği noktada ilgimç fonksiyonlar kullanılmaktadır. Bu fonksiyonlar genellikle network ve process bağlantılı fonksiyonlardır. Mesela, **recv**, **CloseHandle**, **CreatePipe**, **CreateProcessA**, **Sleep** gibi fonksiyonlar ve program akışı bizlere, bir remote shell açıldığını göstermektedir.

![](/Lab-5/images/Lab5-5-image4.png "lab5")


**9-  In the same area, at 0x100101C8, it looks like dword_1008E5C4 is a global variable that helps decide which path to take. How does the malware set dword_1008E5C4? (Hint: Use dword_1008E5C4’s cross-references.)**

dword_1008E5C4 değişkeninin üzerine gelip **x** tuşuna bastığımızda, 3 adet yerde bu değişkenin kullanıldığını görüyoruz. Bunlardan 2 tanesi `cmp` işlemi 1 tanesi ise `mov` işlemidir. Bizim aradığımız `mov` işleminin olduğu **sub_10001656** fonksiyonunun 22. satırı. Oraya geldiğimizde aşağıdaki görselde de görüldüğü üzere, değişkenimize eax register'ı atanmıştır. Lakin bu atamadan önce **`sub_10003695`** fonksiyonu çağırılmıştır.

![](/Lab-5/images/Lab5-5-image5.png "lab5")

O fonksiyonun içerisine girdiğimizde ise, işletim sistemi versiyonunu ifade eden `VersionInformation.dwPlatformId` değişkeni 2 değeri ile karşılaştırılmaktadır. Eğer bu 2 değer eşit ise, eax registerının ilk byte'ı set edilmekte yani 1 yapılmaktadır. Değilse 0 olarak kalmaktadır. Aşağıdaki görselde bu anlatılanları görebilirsiniz.

![](/Lab-5/images/Lab5-5-image6.png "lab5")

**10- A few hundred lines into the subroutine at 0x1000FF58, a series of comparisons use memcmp to compare strings. What happens if the string comparison to robotwork is successful (when memcmp returns 0)?**

Öncelikli olarak C dilindeki `memcmp` fonksiyonunun nasıl çalıştığını bilmekte fayda var. Bu fonksiyon 3 adet parametre almakta ve interger bir değer dönmektedir. Yapısı aşağıdaki gibidir.

```C
int memcmp(const void *str1, const void *str2, size_t n)
```

Aşağıdaki görselde ise strcmp fonksiyonu çağırılmadan önce bu parametreler stack'e pushlanmaktadır. İlk değer olan 9, robotwork stringinin uzunluğunu, `ebp+var5C0` değişkeni ise hacker'dan gelen komutu, `offset aRobotwork` ise zararlının tanımladığı özel bir komutu temsil etmektedir. Hacker'dan gelen komut ile robotwork karşılaştırılmaktadır. Eğer gelen komut, robotwork'e eşit değilse diğer bir komut olan `mbase` ile karşılaştırılmaktadır. Sanki burada bir **if-else** yapısı var gibidir. Aşağıdaki görselde bu yapıyı graph üzerinden görebilirsiniz. Bu yapı görselde görüldüğünden biraz daha dallanıp, budaklanmaktadır. Özetle ebp+var_5C0 değeri birçok string ile karşılaştırılmaktadır.

![](/Lab-5/images/Lab5-5-image7.png "lab5")


Eğer eşit ise, uygulama `sub_100052A2` fonksiyonuna dallanmaktadır. Bu fonksiyonun içerisine girdiğimizde ise `SOFTWARE\Microsoft\Windows\CurrentVersion` registery değerine erişildiği görmekteyiz. Buradan WorkTime ve WorkTimes değerleri sorgulanmakta ve dönen sonuçlar açılan shell bağlantısı üzerinden hacker'a gönderilmektedir. Aşağıdaki görselde assembly kodu gösterilmektedir.

![](/Lab-5/images/Lab5-5-image8.png "lab5")

**11- What does the export PSLIST do?**

İnternette PSLIST fonksiyonunu incelediğim vakit aşağıdaki açıklamayı buldum.

> The default information listed includes the time the process has executed, the amount of time the process has executed in kernel and user modes, and the amount of physical memory that the OS has assigned the process. When running PsList against a remote system you must have administrative rights on that system, and the system must be running the Remote Registry service.

Yani özetle, çalıştırılan bir process hakkında detaylı bilgi sunmaktadır.

**12- Use the graph mode to graph the cross-references from sub_10004E79. Which API functions could be called by entering this function? Based on the API functions alone, what could you rename this function?**

Aşağıdaki görselde `sub_10004E79` foknsiyonunun çağırmış olduğu diğer fonksiyonlar graph olarak gösterilmiştir. Bu graph'a bakarak, bu fonksiyonun system'in default language'ını öğrenip bunu gönderdiği yorumu yapılabilir. İsmini ise ben LanguageDetectAndSend olarak değiştirirdim.

![](/Lab-5/images/Lab5-5-image9.png "lab5")

**13- How many Windows API functions does DllMain call directly? How many at a depth of 2?**


**14- At 0x10001358, there is a call to Sleep (an API function that takes one parameter containing the number of milliseconds to sleep). Looking backward through the code, how long will the program sleep if this code executes?**

İlgili adresteki kod bloğuna gittiğimiz vakit, 0x10019020 adresi, eax registerına atanmaktadır. O adrese gittiğimizde ise "[This is CTI]30" şeklinde bir string tanımlaması görmekteyiz. Daha sonraki instruction olan `add eax, 0Dh` ile eax registerına 13 eklenmektedir. Böylelikle artık eax registerındaki adres **30** değerini göstermektedir. Daha sonra bu 30 değeri integer'a `atoi` fonksiyonu ile dönüştürülmektedir. Son olarakta `imul eax, 3e8h` instruction'ı ile 30 değeri 1000 ile çarpılmakta ve sonuç eax registerına atanmaktadır. Özetle 30000 milisaniye `sleep` fonksiyonuna parametre olarak verilmektedir, buda 30 saniye yapmaktadır.

![](/Lab-5/images/Lab5-5-image11.png "lab5")

**15- At 0x10001701 is a call to socket. What are the three parameters?**

Parametreler 6, 1, ve 2 şeklindedir. Bu integer değerlerin anlamını ise şu şekilde izah edelim.

socket() fonksiyonunun yapısı `int sockfd = socket(domain, type, protocol)` şeklindedir. IDA Pro'da bizim için hangi interger değerin, hangi parametreye denk geldiğini sağolsun bize çıkartmış. Bu durumda bizim, integerdan yola çıkarak bu değerlerin nelere denk geldiğini bulmamız gerekmektedir. [Bu linkten linux socket tanımlamalarını](http://students.mimuw.edu.pl/SO/Linux/Kod/include/linux/socket.h.html) görebilirsiniz. Buradan hareketle;

- AF_INET = 2
- SOCK_STREAM = 1
- IPPROTO_TCP = 6

olarak çıkarılabilir.

![](/Lab-5/images/Lab5-5-image10.png "lab5")

**17- Search for usage of the in instruction (opcode 0xED). This instruction is used with a magic string VMXh to perform VMware detection. Is that in use in this malware? Using the cross-references to the function that executes the in instruction, is there further evidence of VMware detection?**

0x100061DB adresinde VMXh değeri kullanılmaktadır. Dolayısıyla VMWare detection işlemi uygulanıyor diyebiliriz.

**18- Jump your cursor to 0x1001D988. What do you find?**

Belirtilen adrese gidildiğince **-1::',27h,'u<&u!=<&u746>1::',27h,'yu&!',27h,'<;2u106:101u3:',27h,'u'** şeklinde tuhaf karakterler oluşan bir string bulunmaktadır. Büyük ihtimalle encode edilmiş bir içerik.

**19- If you have the IDA Python plug-in installed (included with the commercial version of IDA Pro), run Lab05-01.py, an IDA Pro Python script provided with the malware for this book. (Make sure the cursor is at 0x1001D988.) What happens after you run the script?**

Lab05-01.py dosyası çalıştırıldığında encode edilmiş string ifade decode edilmekte ve **xdoor is this backdoor, string decoded for** ifadesi ortaya çıkmatadır.

**20- With the cursor in the same location, how do you turn this data into a single ASCII string?**

Başlangıç kısmına gelip A tuşuna basmak yeterli olacaktır.

**21- Open the script with a text editor. How does it work?**

Script incelendiğinde, cursor'un bulunduğu adresten itibaren string'in sonuna kadar tüm ifadeler tek tek alınıp, byte'a çevrilmekte ve daha sonra 0x55 değeri ile her değer XOR işlemine tabi tutulmaktadır.















